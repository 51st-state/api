// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/51st-state/api/pkg/apis/user"
	"github.com/51st-state/api/pkg/rbac"
)

type FakeManager struct {
	GetStub        func(ctx context.Context, id user.Identifier) (user.Complete, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		ctx context.Context
		id  user.Identifier
	}
	getReturns struct {
		result1 user.Complete
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 user.Complete
		result2 error
	}
	GetByGameSerialHashStub        func(ctx context.Context, hash string) (user.Complete, error)
	getByGameSerialHashMutex       sync.RWMutex
	getByGameSerialHashArgsForCall []struct {
		ctx  context.Context
		hash string
	}
	getByGameSerialHashReturns struct {
		result1 user.Complete
		result2 error
	}
	getByGameSerialHashReturnsOnCall map[int]struct {
		result1 user.Complete
		result2 error
	}
	GetByWCFUserIDStub        func(ctx context.Context, wcfUserID user.WCFUserID) (user.Complete, error)
	getByWCFUserIDMutex       sync.RWMutex
	getByWCFUserIDArgsForCall []struct {
		ctx       context.Context
		wcfUserID user.WCFUserID
	}
	getByWCFUserIDReturns struct {
		result1 user.Complete
		result2 error
	}
	getByWCFUserIDReturnsOnCall map[int]struct {
		result1 user.Complete
		result2 error
	}
	CreateStub        func(ctx context.Context, inc user.Incomplete) (user.Complete, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		ctx context.Context
		inc user.Incomplete
	}
	createReturns struct {
		result1 user.Complete
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 user.Complete
		result2 error
	}
	DeleteStub        func(ctx context.Context, id user.Identifier) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		ctx context.Context
		id  user.Identifier
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	GetWCFInfoStub        func(ctx context.Context, name string) (*user.WCFUserInfo, error)
	getWCFInfoMutex       sync.RWMutex
	getWCFInfoArgsForCall []struct {
		ctx  context.Context
		name string
	}
	getWCFInfoReturns struct {
		result1 *user.WCFUserInfo
		result2 error
	}
	getWCFInfoReturnsOnCall map[int]struct {
		result1 *user.WCFUserInfo
		result2 error
	}
	UpdateStub        func(ctx context.Context, c user.Complete) error
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		ctx context.Context
		c   user.Complete
	}
	updateReturns struct {
		result1 error
	}
	updateReturnsOnCall map[int]struct {
		result1 error
	}
	CheckPasswordStub        func(ctx context.Context, id user.Identifier, incPw user.IncompletePassword) error
	checkPasswordMutex       sync.RWMutex
	checkPasswordArgsForCall []struct {
		ctx   context.Context
		id    user.Identifier
		incPw user.IncompletePassword
	}
	checkPasswordReturns struct {
		result1 error
	}
	checkPasswordReturnsOnCall map[int]struct {
		result1 error
	}
	GetRolesStub        func(ctx context.Context, id user.Identifier) (rbac.AccountRoles, error)
	getRolesMutex       sync.RWMutex
	getRolesArgsForCall []struct {
		ctx context.Context
		id  user.Identifier
	}
	getRolesReturns struct {
		result1 rbac.AccountRoles
		result2 error
	}
	getRolesReturnsOnCall map[int]struct {
		result1 rbac.AccountRoles
		result2 error
	}
	SetRolesStub        func(ctx context.Context, id user.Identifier, roles rbac.AccountRoles) error
	setRolesMutex       sync.RWMutex
	setRolesArgsForCall []struct {
		ctx   context.Context
		id    user.Identifier
		roles rbac.AccountRoles
	}
	setRolesReturns struct {
		result1 error
	}
	setRolesReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeManager) Get(ctx context.Context, id user.Identifier) (user.Complete, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		ctx context.Context
		id  user.Identifier
	}{ctx, id})
	fake.recordInvocation("Get", []interface{}{ctx, id})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(ctx, id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getReturns.result1, fake.getReturns.result2
}

func (fake *FakeManager) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeManager) GetArgsForCall(i int) (context.Context, user.Identifier) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].ctx, fake.getArgsForCall[i].id
}

func (fake *FakeManager) GetReturns(result1 user.Complete, result2 error) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 user.Complete
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetReturnsOnCall(i int, result1 user.Complete, result2 error) {
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 user.Complete
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 user.Complete
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetByGameSerialHash(ctx context.Context, hash string) (user.Complete, error) {
	fake.getByGameSerialHashMutex.Lock()
	ret, specificReturn := fake.getByGameSerialHashReturnsOnCall[len(fake.getByGameSerialHashArgsForCall)]
	fake.getByGameSerialHashArgsForCall = append(fake.getByGameSerialHashArgsForCall, struct {
		ctx  context.Context
		hash string
	}{ctx, hash})
	fake.recordInvocation("GetByGameSerialHash", []interface{}{ctx, hash})
	fake.getByGameSerialHashMutex.Unlock()
	if fake.GetByGameSerialHashStub != nil {
		return fake.GetByGameSerialHashStub(ctx, hash)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getByGameSerialHashReturns.result1, fake.getByGameSerialHashReturns.result2
}

func (fake *FakeManager) GetByGameSerialHashCallCount() int {
	fake.getByGameSerialHashMutex.RLock()
	defer fake.getByGameSerialHashMutex.RUnlock()
	return len(fake.getByGameSerialHashArgsForCall)
}

func (fake *FakeManager) GetByGameSerialHashArgsForCall(i int) (context.Context, string) {
	fake.getByGameSerialHashMutex.RLock()
	defer fake.getByGameSerialHashMutex.RUnlock()
	return fake.getByGameSerialHashArgsForCall[i].ctx, fake.getByGameSerialHashArgsForCall[i].hash
}

func (fake *FakeManager) GetByGameSerialHashReturns(result1 user.Complete, result2 error) {
	fake.GetByGameSerialHashStub = nil
	fake.getByGameSerialHashReturns = struct {
		result1 user.Complete
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetByGameSerialHashReturnsOnCall(i int, result1 user.Complete, result2 error) {
	fake.GetByGameSerialHashStub = nil
	if fake.getByGameSerialHashReturnsOnCall == nil {
		fake.getByGameSerialHashReturnsOnCall = make(map[int]struct {
			result1 user.Complete
			result2 error
		})
	}
	fake.getByGameSerialHashReturnsOnCall[i] = struct {
		result1 user.Complete
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetByWCFUserID(ctx context.Context, wcfUserID user.WCFUserID) (user.Complete, error) {
	fake.getByWCFUserIDMutex.Lock()
	ret, specificReturn := fake.getByWCFUserIDReturnsOnCall[len(fake.getByWCFUserIDArgsForCall)]
	fake.getByWCFUserIDArgsForCall = append(fake.getByWCFUserIDArgsForCall, struct {
		ctx       context.Context
		wcfUserID user.WCFUserID
	}{ctx, wcfUserID})
	fake.recordInvocation("GetByWCFUserID", []interface{}{ctx, wcfUserID})
	fake.getByWCFUserIDMutex.Unlock()
	if fake.GetByWCFUserIDStub != nil {
		return fake.GetByWCFUserIDStub(ctx, wcfUserID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getByWCFUserIDReturns.result1, fake.getByWCFUserIDReturns.result2
}

func (fake *FakeManager) GetByWCFUserIDCallCount() int {
	fake.getByWCFUserIDMutex.RLock()
	defer fake.getByWCFUserIDMutex.RUnlock()
	return len(fake.getByWCFUserIDArgsForCall)
}

func (fake *FakeManager) GetByWCFUserIDArgsForCall(i int) (context.Context, user.WCFUserID) {
	fake.getByWCFUserIDMutex.RLock()
	defer fake.getByWCFUserIDMutex.RUnlock()
	return fake.getByWCFUserIDArgsForCall[i].ctx, fake.getByWCFUserIDArgsForCall[i].wcfUserID
}

func (fake *FakeManager) GetByWCFUserIDReturns(result1 user.Complete, result2 error) {
	fake.GetByWCFUserIDStub = nil
	fake.getByWCFUserIDReturns = struct {
		result1 user.Complete
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetByWCFUserIDReturnsOnCall(i int, result1 user.Complete, result2 error) {
	fake.GetByWCFUserIDStub = nil
	if fake.getByWCFUserIDReturnsOnCall == nil {
		fake.getByWCFUserIDReturnsOnCall = make(map[int]struct {
			result1 user.Complete
			result2 error
		})
	}
	fake.getByWCFUserIDReturnsOnCall[i] = struct {
		result1 user.Complete
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Create(ctx context.Context, inc user.Incomplete) (user.Complete, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		ctx context.Context
		inc user.Incomplete
	}{ctx, inc})
	fake.recordInvocation("Create", []interface{}{ctx, inc})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(ctx, inc)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createReturns.result1, fake.createReturns.result2
}

func (fake *FakeManager) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeManager) CreateArgsForCall(i int) (context.Context, user.Incomplete) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].ctx, fake.createArgsForCall[i].inc
}

func (fake *FakeManager) CreateReturns(result1 user.Complete, result2 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 user.Complete
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) CreateReturnsOnCall(i int, result1 user.Complete, result2 error) {
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 user.Complete
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 user.Complete
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Delete(ctx context.Context, id user.Identifier) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		ctx context.Context
		id  user.Identifier
	}{ctx, id})
	fake.recordInvocation("Delete", []interface{}{ctx, id})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(ctx, id)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteReturns.result1
}

func (fake *FakeManager) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeManager) DeleteArgsForCall(i int) (context.Context, user.Identifier) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].ctx, fake.deleteArgsForCall[i].id
}

func (fake *FakeManager) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) DeleteReturnsOnCall(i int, result1 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) GetWCFInfo(ctx context.Context, name string) (*user.WCFUserInfo, error) {
	fake.getWCFInfoMutex.Lock()
	ret, specificReturn := fake.getWCFInfoReturnsOnCall[len(fake.getWCFInfoArgsForCall)]
	fake.getWCFInfoArgsForCall = append(fake.getWCFInfoArgsForCall, struct {
		ctx  context.Context
		name string
	}{ctx, name})
	fake.recordInvocation("GetWCFInfo", []interface{}{ctx, name})
	fake.getWCFInfoMutex.Unlock()
	if fake.GetWCFInfoStub != nil {
		return fake.GetWCFInfoStub(ctx, name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getWCFInfoReturns.result1, fake.getWCFInfoReturns.result2
}

func (fake *FakeManager) GetWCFInfoCallCount() int {
	fake.getWCFInfoMutex.RLock()
	defer fake.getWCFInfoMutex.RUnlock()
	return len(fake.getWCFInfoArgsForCall)
}

func (fake *FakeManager) GetWCFInfoArgsForCall(i int) (context.Context, string) {
	fake.getWCFInfoMutex.RLock()
	defer fake.getWCFInfoMutex.RUnlock()
	return fake.getWCFInfoArgsForCall[i].ctx, fake.getWCFInfoArgsForCall[i].name
}

func (fake *FakeManager) GetWCFInfoReturns(result1 *user.WCFUserInfo, result2 error) {
	fake.GetWCFInfoStub = nil
	fake.getWCFInfoReturns = struct {
		result1 *user.WCFUserInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetWCFInfoReturnsOnCall(i int, result1 *user.WCFUserInfo, result2 error) {
	fake.GetWCFInfoStub = nil
	if fake.getWCFInfoReturnsOnCall == nil {
		fake.getWCFInfoReturnsOnCall = make(map[int]struct {
			result1 *user.WCFUserInfo
			result2 error
		})
	}
	fake.getWCFInfoReturnsOnCall[i] = struct {
		result1 *user.WCFUserInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Update(ctx context.Context, c user.Complete) error {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		ctx context.Context
		c   user.Complete
	}{ctx, c})
	fake.recordInvocation("Update", []interface{}{ctx, c})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(ctx, c)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateReturns.result1
}

func (fake *FakeManager) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeManager) UpdateArgsForCall(i int) (context.Context, user.Complete) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].ctx, fake.updateArgsForCall[i].c
}

func (fake *FakeManager) UpdateReturns(result1 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) UpdateReturnsOnCall(i int, result1 error) {
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) CheckPassword(ctx context.Context, id user.Identifier, incPw user.IncompletePassword) error {
	fake.checkPasswordMutex.Lock()
	ret, specificReturn := fake.checkPasswordReturnsOnCall[len(fake.checkPasswordArgsForCall)]
	fake.checkPasswordArgsForCall = append(fake.checkPasswordArgsForCall, struct {
		ctx   context.Context
		id    user.Identifier
		incPw user.IncompletePassword
	}{ctx, id, incPw})
	fake.recordInvocation("CheckPassword", []interface{}{ctx, id, incPw})
	fake.checkPasswordMutex.Unlock()
	if fake.CheckPasswordStub != nil {
		return fake.CheckPasswordStub(ctx, id, incPw)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.checkPasswordReturns.result1
}

func (fake *FakeManager) CheckPasswordCallCount() int {
	fake.checkPasswordMutex.RLock()
	defer fake.checkPasswordMutex.RUnlock()
	return len(fake.checkPasswordArgsForCall)
}

func (fake *FakeManager) CheckPasswordArgsForCall(i int) (context.Context, user.Identifier, user.IncompletePassword) {
	fake.checkPasswordMutex.RLock()
	defer fake.checkPasswordMutex.RUnlock()
	return fake.checkPasswordArgsForCall[i].ctx, fake.checkPasswordArgsForCall[i].id, fake.checkPasswordArgsForCall[i].incPw
}

func (fake *FakeManager) CheckPasswordReturns(result1 error) {
	fake.CheckPasswordStub = nil
	fake.checkPasswordReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) CheckPasswordReturnsOnCall(i int, result1 error) {
	fake.CheckPasswordStub = nil
	if fake.checkPasswordReturnsOnCall == nil {
		fake.checkPasswordReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkPasswordReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) GetRoles(ctx context.Context, id user.Identifier) (rbac.AccountRoles, error) {
	fake.getRolesMutex.Lock()
	ret, specificReturn := fake.getRolesReturnsOnCall[len(fake.getRolesArgsForCall)]
	fake.getRolesArgsForCall = append(fake.getRolesArgsForCall, struct {
		ctx context.Context
		id  user.Identifier
	}{ctx, id})
	fake.recordInvocation("GetRoles", []interface{}{ctx, id})
	fake.getRolesMutex.Unlock()
	if fake.GetRolesStub != nil {
		return fake.GetRolesStub(ctx, id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getRolesReturns.result1, fake.getRolesReturns.result2
}

func (fake *FakeManager) GetRolesCallCount() int {
	fake.getRolesMutex.RLock()
	defer fake.getRolesMutex.RUnlock()
	return len(fake.getRolesArgsForCall)
}

func (fake *FakeManager) GetRolesArgsForCall(i int) (context.Context, user.Identifier) {
	fake.getRolesMutex.RLock()
	defer fake.getRolesMutex.RUnlock()
	return fake.getRolesArgsForCall[i].ctx, fake.getRolesArgsForCall[i].id
}

func (fake *FakeManager) GetRolesReturns(result1 rbac.AccountRoles, result2 error) {
	fake.GetRolesStub = nil
	fake.getRolesReturns = struct {
		result1 rbac.AccountRoles
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetRolesReturnsOnCall(i int, result1 rbac.AccountRoles, result2 error) {
	fake.GetRolesStub = nil
	if fake.getRolesReturnsOnCall == nil {
		fake.getRolesReturnsOnCall = make(map[int]struct {
			result1 rbac.AccountRoles
			result2 error
		})
	}
	fake.getRolesReturnsOnCall[i] = struct {
		result1 rbac.AccountRoles
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) SetRoles(ctx context.Context, id user.Identifier, roles rbac.AccountRoles) error {
	fake.setRolesMutex.Lock()
	ret, specificReturn := fake.setRolesReturnsOnCall[len(fake.setRolesArgsForCall)]
	fake.setRolesArgsForCall = append(fake.setRolesArgsForCall, struct {
		ctx   context.Context
		id    user.Identifier
		roles rbac.AccountRoles
	}{ctx, id, roles})
	fake.recordInvocation("SetRoles", []interface{}{ctx, id, roles})
	fake.setRolesMutex.Unlock()
	if fake.SetRolesStub != nil {
		return fake.SetRolesStub(ctx, id, roles)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setRolesReturns.result1
}

func (fake *FakeManager) SetRolesCallCount() int {
	fake.setRolesMutex.RLock()
	defer fake.setRolesMutex.RUnlock()
	return len(fake.setRolesArgsForCall)
}

func (fake *FakeManager) SetRolesArgsForCall(i int) (context.Context, user.Identifier, rbac.AccountRoles) {
	fake.setRolesMutex.RLock()
	defer fake.setRolesMutex.RUnlock()
	return fake.setRolesArgsForCall[i].ctx, fake.setRolesArgsForCall[i].id, fake.setRolesArgsForCall[i].roles
}

func (fake *FakeManager) SetRolesReturns(result1 error) {
	fake.SetRolesStub = nil
	fake.setRolesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) SetRolesReturnsOnCall(i int, result1 error) {
	fake.SetRolesStub = nil
	if fake.setRolesReturnsOnCall == nil {
		fake.setRolesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setRolesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getByGameSerialHashMutex.RLock()
	defer fake.getByGameSerialHashMutex.RUnlock()
	fake.getByWCFUserIDMutex.RLock()
	defer fake.getByWCFUserIDMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.getWCFInfoMutex.RLock()
	defer fake.getWCFInfoMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.checkPasswordMutex.RLock()
	defer fake.checkPasswordMutex.RUnlock()
	fake.getRolesMutex.RLock()
	defer fake.getRolesMutex.RUnlock()
	fake.setRolesMutex.RLock()
	defer fake.setRolesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ user.Manager = new(FakeManager)
