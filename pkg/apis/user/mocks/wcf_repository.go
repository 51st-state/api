// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/51st-state/api/pkg/apis/user"
)

type FakeWCFRepository struct {
	GetInfoStub        func(context.Context, user.WCFUserID) (*user.WCFUserInfo, error)
	getInfoMutex       sync.RWMutex
	getInfoArgsForCall []struct {
		arg1 context.Context
		arg2 user.WCFUserID
	}
	getInfoReturns struct {
		result1 *user.WCFUserInfo
		result2 error
	}
	getInfoReturnsOnCall map[int]struct {
		result1 *user.WCFUserInfo
		result2 error
	}
	GetInfoByEmailStub        func(context.Context, string) (*user.WCFUserInfo, error)
	getInfoByEmailMutex       sync.RWMutex
	getInfoByEmailArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getInfoByEmailReturns struct {
		result1 *user.WCFUserInfo
		result2 error
	}
	getInfoByEmailReturnsOnCall map[int]struct {
		result1 *user.WCFUserInfo
		result2 error
	}
	GetInfoByUsernameStub        func(context.Context, string) (*user.WCFUserInfo, error)
	getInfoByUsernameMutex       sync.RWMutex
	getInfoByUsernameArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getInfoByUsernameReturns struct {
		result1 *user.WCFUserInfo
		result2 error
	}
	getInfoByUsernameReturnsOnCall map[int]struct {
		result1 *user.WCFUserInfo
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWCFRepository) GetInfo(arg1 context.Context, arg2 user.WCFUserID) (*user.WCFUserInfo, error) {
	fake.getInfoMutex.Lock()
	ret, specificReturn := fake.getInfoReturnsOnCall[len(fake.getInfoArgsForCall)]
	fake.getInfoArgsForCall = append(fake.getInfoArgsForCall, struct {
		arg1 context.Context
		arg2 user.WCFUserID
	}{arg1, arg2})
	fake.recordInvocation("GetInfo", []interface{}{arg1, arg2})
	fake.getInfoMutex.Unlock()
	if fake.GetInfoStub != nil {
		return fake.GetInfoStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getInfoReturns.result1, fake.getInfoReturns.result2
}

func (fake *FakeWCFRepository) GetInfoCallCount() int {
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	return len(fake.getInfoArgsForCall)
}

func (fake *FakeWCFRepository) GetInfoArgsForCall(i int) (context.Context, user.WCFUserID) {
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	return fake.getInfoArgsForCall[i].arg1, fake.getInfoArgsForCall[i].arg2
}

func (fake *FakeWCFRepository) GetInfoReturns(result1 *user.WCFUserInfo, result2 error) {
	fake.GetInfoStub = nil
	fake.getInfoReturns = struct {
		result1 *user.WCFUserInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeWCFRepository) GetInfoReturnsOnCall(i int, result1 *user.WCFUserInfo, result2 error) {
	fake.GetInfoStub = nil
	if fake.getInfoReturnsOnCall == nil {
		fake.getInfoReturnsOnCall = make(map[int]struct {
			result1 *user.WCFUserInfo
			result2 error
		})
	}
	fake.getInfoReturnsOnCall[i] = struct {
		result1 *user.WCFUserInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeWCFRepository) GetInfoByEmail(arg1 context.Context, arg2 string) (*user.WCFUserInfo, error) {
	fake.getInfoByEmailMutex.Lock()
	ret, specificReturn := fake.getInfoByEmailReturnsOnCall[len(fake.getInfoByEmailArgsForCall)]
	fake.getInfoByEmailArgsForCall = append(fake.getInfoByEmailArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetInfoByEmail", []interface{}{arg1, arg2})
	fake.getInfoByEmailMutex.Unlock()
	if fake.GetInfoByEmailStub != nil {
		return fake.GetInfoByEmailStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getInfoByEmailReturns.result1, fake.getInfoByEmailReturns.result2
}

func (fake *FakeWCFRepository) GetInfoByEmailCallCount() int {
	fake.getInfoByEmailMutex.RLock()
	defer fake.getInfoByEmailMutex.RUnlock()
	return len(fake.getInfoByEmailArgsForCall)
}

func (fake *FakeWCFRepository) GetInfoByEmailArgsForCall(i int) (context.Context, string) {
	fake.getInfoByEmailMutex.RLock()
	defer fake.getInfoByEmailMutex.RUnlock()
	return fake.getInfoByEmailArgsForCall[i].arg1, fake.getInfoByEmailArgsForCall[i].arg2
}

func (fake *FakeWCFRepository) GetInfoByEmailReturns(result1 *user.WCFUserInfo, result2 error) {
	fake.GetInfoByEmailStub = nil
	fake.getInfoByEmailReturns = struct {
		result1 *user.WCFUserInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeWCFRepository) GetInfoByEmailReturnsOnCall(i int, result1 *user.WCFUserInfo, result2 error) {
	fake.GetInfoByEmailStub = nil
	if fake.getInfoByEmailReturnsOnCall == nil {
		fake.getInfoByEmailReturnsOnCall = make(map[int]struct {
			result1 *user.WCFUserInfo
			result2 error
		})
	}
	fake.getInfoByEmailReturnsOnCall[i] = struct {
		result1 *user.WCFUserInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeWCFRepository) GetInfoByUsername(arg1 context.Context, arg2 string) (*user.WCFUserInfo, error) {
	fake.getInfoByUsernameMutex.Lock()
	ret, specificReturn := fake.getInfoByUsernameReturnsOnCall[len(fake.getInfoByUsernameArgsForCall)]
	fake.getInfoByUsernameArgsForCall = append(fake.getInfoByUsernameArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetInfoByUsername", []interface{}{arg1, arg2})
	fake.getInfoByUsernameMutex.Unlock()
	if fake.GetInfoByUsernameStub != nil {
		return fake.GetInfoByUsernameStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getInfoByUsernameReturns.result1, fake.getInfoByUsernameReturns.result2
}

func (fake *FakeWCFRepository) GetInfoByUsernameCallCount() int {
	fake.getInfoByUsernameMutex.RLock()
	defer fake.getInfoByUsernameMutex.RUnlock()
	return len(fake.getInfoByUsernameArgsForCall)
}

func (fake *FakeWCFRepository) GetInfoByUsernameArgsForCall(i int) (context.Context, string) {
	fake.getInfoByUsernameMutex.RLock()
	defer fake.getInfoByUsernameMutex.RUnlock()
	return fake.getInfoByUsernameArgsForCall[i].arg1, fake.getInfoByUsernameArgsForCall[i].arg2
}

func (fake *FakeWCFRepository) GetInfoByUsernameReturns(result1 *user.WCFUserInfo, result2 error) {
	fake.GetInfoByUsernameStub = nil
	fake.getInfoByUsernameReturns = struct {
		result1 *user.WCFUserInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeWCFRepository) GetInfoByUsernameReturnsOnCall(i int, result1 *user.WCFUserInfo, result2 error) {
	fake.GetInfoByUsernameStub = nil
	if fake.getInfoByUsernameReturnsOnCall == nil {
		fake.getInfoByUsernameReturnsOnCall = make(map[int]struct {
			result1 *user.WCFUserInfo
			result2 error
		})
	}
	fake.getInfoByUsernameReturnsOnCall[i] = struct {
		result1 *user.WCFUserInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeWCFRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	fake.getInfoByEmailMutex.RLock()
	defer fake.getInfoByEmailMutex.RUnlock()
	fake.getInfoByUsernameMutex.RLock()
	defer fake.getInfoByUsernameMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWCFRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ user.WCFRepository = new(FakeWCFRepository)
