// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/51st-state/api/pkg/rbac"
)

type FakeRepository struct {
	GetRoleRulesStub        func(context.Context, rbac.RoleID) (rbac.RoleRules, error)
	getRoleRulesMutex       sync.RWMutex
	getRoleRulesArgsForCall []struct {
		arg1 context.Context
		arg2 rbac.RoleID
	}
	getRoleRulesReturns struct {
		result1 rbac.RoleRules
		result2 error
	}
	getRoleRulesReturnsOnCall map[int]struct {
		result1 rbac.RoleRules
		result2 error
	}
	SetRoleRulesStub        func(context.Context, rbac.RoleID, rbac.RoleRules) error
	setRoleRulesMutex       sync.RWMutex
	setRoleRulesArgsForCall []struct {
		arg1 context.Context
		arg2 rbac.RoleID
		arg3 rbac.RoleRules
	}
	setRoleRulesReturns struct {
		result1 error
	}
	setRoleRulesReturnsOnCall map[int]struct {
		result1 error
	}
	GetAccountRolesStub        func(context.Context, rbac.AccountID) (rbac.AccountRoles, error)
	getAccountRolesMutex       sync.RWMutex
	getAccountRolesArgsForCall []struct {
		arg1 context.Context
		arg2 rbac.AccountID
	}
	getAccountRolesReturns struct {
		result1 rbac.AccountRoles
		result2 error
	}
	getAccountRolesReturnsOnCall map[int]struct {
		result1 rbac.AccountRoles
		result2 error
	}
	SetAccountRolesStub        func(context.Context, rbac.AccountID, rbac.AccountRoles) error
	setAccountRolesMutex       sync.RWMutex
	setAccountRolesArgsForCall []struct {
		arg1 context.Context
		arg2 rbac.AccountID
		arg3 rbac.AccountRoles
	}
	setAccountRolesReturns struct {
		result1 error
	}
	setAccountRolesReturnsOnCall map[int]struct {
		result1 error
	}
	GetAccountRuleCountStub        func(context.Context, rbac.AccountID, rbac.Rule) (uint64, error)
	getAccountRuleCountMutex       sync.RWMutex
	getAccountRuleCountArgsForCall []struct {
		arg1 context.Context
		arg2 rbac.AccountID
		arg3 rbac.Rule
	}
	getAccountRuleCountReturns struct {
		result1 uint64
		result2 error
	}
	getAccountRuleCountReturnsOnCall map[int]struct {
		result1 uint64
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRepository) GetRoleRules(arg1 context.Context, arg2 rbac.RoleID) (rbac.RoleRules, error) {
	fake.getRoleRulesMutex.Lock()
	ret, specificReturn := fake.getRoleRulesReturnsOnCall[len(fake.getRoleRulesArgsForCall)]
	fake.getRoleRulesArgsForCall = append(fake.getRoleRulesArgsForCall, struct {
		arg1 context.Context
		arg2 rbac.RoleID
	}{arg1, arg2})
	fake.recordInvocation("GetRoleRules", []interface{}{arg1, arg2})
	fake.getRoleRulesMutex.Unlock()
	if fake.GetRoleRulesStub != nil {
		return fake.GetRoleRulesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getRoleRulesReturns.result1, fake.getRoleRulesReturns.result2
}

func (fake *FakeRepository) GetRoleRulesCallCount() int {
	fake.getRoleRulesMutex.RLock()
	defer fake.getRoleRulesMutex.RUnlock()
	return len(fake.getRoleRulesArgsForCall)
}

func (fake *FakeRepository) GetRoleRulesArgsForCall(i int) (context.Context, rbac.RoleID) {
	fake.getRoleRulesMutex.RLock()
	defer fake.getRoleRulesMutex.RUnlock()
	return fake.getRoleRulesArgsForCall[i].arg1, fake.getRoleRulesArgsForCall[i].arg2
}

func (fake *FakeRepository) GetRoleRulesReturns(result1 rbac.RoleRules, result2 error) {
	fake.GetRoleRulesStub = nil
	fake.getRoleRulesReturns = struct {
		result1 rbac.RoleRules
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetRoleRulesReturnsOnCall(i int, result1 rbac.RoleRules, result2 error) {
	fake.GetRoleRulesStub = nil
	if fake.getRoleRulesReturnsOnCall == nil {
		fake.getRoleRulesReturnsOnCall = make(map[int]struct {
			result1 rbac.RoleRules
			result2 error
		})
	}
	fake.getRoleRulesReturnsOnCall[i] = struct {
		result1 rbac.RoleRules
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) SetRoleRules(arg1 context.Context, arg2 rbac.RoleID, arg3 rbac.RoleRules) error {
	fake.setRoleRulesMutex.Lock()
	ret, specificReturn := fake.setRoleRulesReturnsOnCall[len(fake.setRoleRulesArgsForCall)]
	fake.setRoleRulesArgsForCall = append(fake.setRoleRulesArgsForCall, struct {
		arg1 context.Context
		arg2 rbac.RoleID
		arg3 rbac.RoleRules
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetRoleRules", []interface{}{arg1, arg2, arg3})
	fake.setRoleRulesMutex.Unlock()
	if fake.SetRoleRulesStub != nil {
		return fake.SetRoleRulesStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setRoleRulesReturns.result1
}

func (fake *FakeRepository) SetRoleRulesCallCount() int {
	fake.setRoleRulesMutex.RLock()
	defer fake.setRoleRulesMutex.RUnlock()
	return len(fake.setRoleRulesArgsForCall)
}

func (fake *FakeRepository) SetRoleRulesArgsForCall(i int) (context.Context, rbac.RoleID, rbac.RoleRules) {
	fake.setRoleRulesMutex.RLock()
	defer fake.setRoleRulesMutex.RUnlock()
	return fake.setRoleRulesArgsForCall[i].arg1, fake.setRoleRulesArgsForCall[i].arg2, fake.setRoleRulesArgsForCall[i].arg3
}

func (fake *FakeRepository) SetRoleRulesReturns(result1 error) {
	fake.SetRoleRulesStub = nil
	fake.setRoleRulesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) SetRoleRulesReturnsOnCall(i int, result1 error) {
	fake.SetRoleRulesStub = nil
	if fake.setRoleRulesReturnsOnCall == nil {
		fake.setRoleRulesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setRoleRulesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) GetAccountRoles(arg1 context.Context, arg2 rbac.AccountID) (rbac.AccountRoles, error) {
	fake.getAccountRolesMutex.Lock()
	ret, specificReturn := fake.getAccountRolesReturnsOnCall[len(fake.getAccountRolesArgsForCall)]
	fake.getAccountRolesArgsForCall = append(fake.getAccountRolesArgsForCall, struct {
		arg1 context.Context
		arg2 rbac.AccountID
	}{arg1, arg2})
	fake.recordInvocation("GetAccountRoles", []interface{}{arg1, arg2})
	fake.getAccountRolesMutex.Unlock()
	if fake.GetAccountRolesStub != nil {
		return fake.GetAccountRolesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getAccountRolesReturns.result1, fake.getAccountRolesReturns.result2
}

func (fake *FakeRepository) GetAccountRolesCallCount() int {
	fake.getAccountRolesMutex.RLock()
	defer fake.getAccountRolesMutex.RUnlock()
	return len(fake.getAccountRolesArgsForCall)
}

func (fake *FakeRepository) GetAccountRolesArgsForCall(i int) (context.Context, rbac.AccountID) {
	fake.getAccountRolesMutex.RLock()
	defer fake.getAccountRolesMutex.RUnlock()
	return fake.getAccountRolesArgsForCall[i].arg1, fake.getAccountRolesArgsForCall[i].arg2
}

func (fake *FakeRepository) GetAccountRolesReturns(result1 rbac.AccountRoles, result2 error) {
	fake.GetAccountRolesStub = nil
	fake.getAccountRolesReturns = struct {
		result1 rbac.AccountRoles
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetAccountRolesReturnsOnCall(i int, result1 rbac.AccountRoles, result2 error) {
	fake.GetAccountRolesStub = nil
	if fake.getAccountRolesReturnsOnCall == nil {
		fake.getAccountRolesReturnsOnCall = make(map[int]struct {
			result1 rbac.AccountRoles
			result2 error
		})
	}
	fake.getAccountRolesReturnsOnCall[i] = struct {
		result1 rbac.AccountRoles
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) SetAccountRoles(arg1 context.Context, arg2 rbac.AccountID, arg3 rbac.AccountRoles) error {
	fake.setAccountRolesMutex.Lock()
	ret, specificReturn := fake.setAccountRolesReturnsOnCall[len(fake.setAccountRolesArgsForCall)]
	fake.setAccountRolesArgsForCall = append(fake.setAccountRolesArgsForCall, struct {
		arg1 context.Context
		arg2 rbac.AccountID
		arg3 rbac.AccountRoles
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetAccountRoles", []interface{}{arg1, arg2, arg3})
	fake.setAccountRolesMutex.Unlock()
	if fake.SetAccountRolesStub != nil {
		return fake.SetAccountRolesStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setAccountRolesReturns.result1
}

func (fake *FakeRepository) SetAccountRolesCallCount() int {
	fake.setAccountRolesMutex.RLock()
	defer fake.setAccountRolesMutex.RUnlock()
	return len(fake.setAccountRolesArgsForCall)
}

func (fake *FakeRepository) SetAccountRolesArgsForCall(i int) (context.Context, rbac.AccountID, rbac.AccountRoles) {
	fake.setAccountRolesMutex.RLock()
	defer fake.setAccountRolesMutex.RUnlock()
	return fake.setAccountRolesArgsForCall[i].arg1, fake.setAccountRolesArgsForCall[i].arg2, fake.setAccountRolesArgsForCall[i].arg3
}

func (fake *FakeRepository) SetAccountRolesReturns(result1 error) {
	fake.SetAccountRolesStub = nil
	fake.setAccountRolesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) SetAccountRolesReturnsOnCall(i int, result1 error) {
	fake.SetAccountRolesStub = nil
	if fake.setAccountRolesReturnsOnCall == nil {
		fake.setAccountRolesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setAccountRolesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepository) GetAccountRuleCount(arg1 context.Context, arg2 rbac.AccountID, arg3 rbac.Rule) (uint64, error) {
	fake.getAccountRuleCountMutex.Lock()
	ret, specificReturn := fake.getAccountRuleCountReturnsOnCall[len(fake.getAccountRuleCountArgsForCall)]
	fake.getAccountRuleCountArgsForCall = append(fake.getAccountRuleCountArgsForCall, struct {
		arg1 context.Context
		arg2 rbac.AccountID
		arg3 rbac.Rule
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetAccountRuleCount", []interface{}{arg1, arg2, arg3})
	fake.getAccountRuleCountMutex.Unlock()
	if fake.GetAccountRuleCountStub != nil {
		return fake.GetAccountRuleCountStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getAccountRuleCountReturns.result1, fake.getAccountRuleCountReturns.result2
}

func (fake *FakeRepository) GetAccountRuleCountCallCount() int {
	fake.getAccountRuleCountMutex.RLock()
	defer fake.getAccountRuleCountMutex.RUnlock()
	return len(fake.getAccountRuleCountArgsForCall)
}

func (fake *FakeRepository) GetAccountRuleCountArgsForCall(i int) (context.Context, rbac.AccountID, rbac.Rule) {
	fake.getAccountRuleCountMutex.RLock()
	defer fake.getAccountRuleCountMutex.RUnlock()
	return fake.getAccountRuleCountArgsForCall[i].arg1, fake.getAccountRuleCountArgsForCall[i].arg2, fake.getAccountRuleCountArgsForCall[i].arg3
}

func (fake *FakeRepository) GetAccountRuleCountReturns(result1 uint64, result2 error) {
	fake.GetAccountRuleCountStub = nil
	fake.getAccountRuleCountReturns = struct {
		result1 uint64
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) GetAccountRuleCountReturnsOnCall(i int, result1 uint64, result2 error) {
	fake.GetAccountRuleCountStub = nil
	if fake.getAccountRuleCountReturnsOnCall == nil {
		fake.getAccountRuleCountReturnsOnCall = make(map[int]struct {
			result1 uint64
			result2 error
		})
	}
	fake.getAccountRuleCountReturnsOnCall[i] = struct {
		result1 uint64
		result2 error
	}{result1, result2}
}

func (fake *FakeRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getRoleRulesMutex.RLock()
	defer fake.getRoleRulesMutex.RUnlock()
	fake.setRoleRulesMutex.RLock()
	defer fake.setRoleRulesMutex.RUnlock()
	fake.getAccountRolesMutex.RLock()
	defer fake.getAccountRolesMutex.RUnlock()
	fake.setAccountRolesMutex.RLock()
	defer fake.setAccountRolesMutex.RUnlock()
	fake.getAccountRuleCountMutex.RLock()
	defer fake.getAccountRuleCountMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ rbac.Repository = new(FakeRepository)
