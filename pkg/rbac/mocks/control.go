// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/51st-state/api/pkg/rbac"
)

type FakeControl struct {
	GetRoleRulesStub        func(ctx context.Context, roleID rbac.RoleID) (rbac.RoleRules, error)
	getRoleRulesMutex       sync.RWMutex
	getRoleRulesArgsForCall []struct {
		ctx    context.Context
		roleID rbac.RoleID
	}
	getRoleRulesReturns struct {
		result1 rbac.RoleRules
		result2 error
	}
	getRoleRulesReturnsOnCall map[int]struct {
		result1 rbac.RoleRules
		result2 error
	}
	SetRoleRulesStub        func(ctx context.Context, roleID rbac.RoleID, rules rbac.RoleRules) error
	setRoleRulesMutex       sync.RWMutex
	setRoleRulesArgsForCall []struct {
		ctx    context.Context
		roleID rbac.RoleID
		rules  rbac.RoleRules
	}
	setRoleRulesReturns struct {
		result1 error
	}
	setRoleRulesReturnsOnCall map[int]struct {
		result1 error
	}
	GetAccountRolesStub        func(ctx context.Context, accountID rbac.AccountID) (rbac.AccountRoles, error)
	getAccountRolesMutex       sync.RWMutex
	getAccountRolesArgsForCall []struct {
		ctx       context.Context
		accountID rbac.AccountID
	}
	getAccountRolesReturns struct {
		result1 rbac.AccountRoles
		result2 error
	}
	getAccountRolesReturnsOnCall map[int]struct {
		result1 rbac.AccountRoles
		result2 error
	}
	SetAccountRolesStub        func(ctx context.Context, accountID rbac.AccountID, roles rbac.AccountRoles) error
	setAccountRolesMutex       sync.RWMutex
	setAccountRolesArgsForCall []struct {
		ctx       context.Context
		accountID rbac.AccountID
		roles     rbac.AccountRoles
	}
	setAccountRolesReturns struct {
		result1 error
	}
	setAccountRolesReturnsOnCall map[int]struct {
		result1 error
	}
	IsAccountAllowedStub        func(ctx context.Context, accountID rbac.AccountID, rule rbac.Rule) (bool, error)
	isAccountAllowedMutex       sync.RWMutex
	isAccountAllowedArgsForCall []struct {
		ctx       context.Context
		accountID rbac.AccountID
		rule      rbac.Rule
	}
	isAccountAllowedReturns struct {
		result1 bool
		result2 error
	}
	isAccountAllowedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeControl) GetRoleRules(ctx context.Context, roleID rbac.RoleID) (rbac.RoleRules, error) {
	fake.getRoleRulesMutex.Lock()
	ret, specificReturn := fake.getRoleRulesReturnsOnCall[len(fake.getRoleRulesArgsForCall)]
	fake.getRoleRulesArgsForCall = append(fake.getRoleRulesArgsForCall, struct {
		ctx    context.Context
		roleID rbac.RoleID
	}{ctx, roleID})
	fake.recordInvocation("GetRoleRules", []interface{}{ctx, roleID})
	fake.getRoleRulesMutex.Unlock()
	if fake.GetRoleRulesStub != nil {
		return fake.GetRoleRulesStub(ctx, roleID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getRoleRulesReturns.result1, fake.getRoleRulesReturns.result2
}

func (fake *FakeControl) GetRoleRulesCallCount() int {
	fake.getRoleRulesMutex.RLock()
	defer fake.getRoleRulesMutex.RUnlock()
	return len(fake.getRoleRulesArgsForCall)
}

func (fake *FakeControl) GetRoleRulesArgsForCall(i int) (context.Context, rbac.RoleID) {
	fake.getRoleRulesMutex.RLock()
	defer fake.getRoleRulesMutex.RUnlock()
	return fake.getRoleRulesArgsForCall[i].ctx, fake.getRoleRulesArgsForCall[i].roleID
}

func (fake *FakeControl) GetRoleRulesReturns(result1 rbac.RoleRules, result2 error) {
	fake.GetRoleRulesStub = nil
	fake.getRoleRulesReturns = struct {
		result1 rbac.RoleRules
		result2 error
	}{result1, result2}
}

func (fake *FakeControl) GetRoleRulesReturnsOnCall(i int, result1 rbac.RoleRules, result2 error) {
	fake.GetRoleRulesStub = nil
	if fake.getRoleRulesReturnsOnCall == nil {
		fake.getRoleRulesReturnsOnCall = make(map[int]struct {
			result1 rbac.RoleRules
			result2 error
		})
	}
	fake.getRoleRulesReturnsOnCall[i] = struct {
		result1 rbac.RoleRules
		result2 error
	}{result1, result2}
}

func (fake *FakeControl) SetRoleRules(ctx context.Context, roleID rbac.RoleID, rules rbac.RoleRules) error {
	fake.setRoleRulesMutex.Lock()
	ret, specificReturn := fake.setRoleRulesReturnsOnCall[len(fake.setRoleRulesArgsForCall)]
	fake.setRoleRulesArgsForCall = append(fake.setRoleRulesArgsForCall, struct {
		ctx    context.Context
		roleID rbac.RoleID
		rules  rbac.RoleRules
	}{ctx, roleID, rules})
	fake.recordInvocation("SetRoleRules", []interface{}{ctx, roleID, rules})
	fake.setRoleRulesMutex.Unlock()
	if fake.SetRoleRulesStub != nil {
		return fake.SetRoleRulesStub(ctx, roleID, rules)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setRoleRulesReturns.result1
}

func (fake *FakeControl) SetRoleRulesCallCount() int {
	fake.setRoleRulesMutex.RLock()
	defer fake.setRoleRulesMutex.RUnlock()
	return len(fake.setRoleRulesArgsForCall)
}

func (fake *FakeControl) SetRoleRulesArgsForCall(i int) (context.Context, rbac.RoleID, rbac.RoleRules) {
	fake.setRoleRulesMutex.RLock()
	defer fake.setRoleRulesMutex.RUnlock()
	return fake.setRoleRulesArgsForCall[i].ctx, fake.setRoleRulesArgsForCall[i].roleID, fake.setRoleRulesArgsForCall[i].rules
}

func (fake *FakeControl) SetRoleRulesReturns(result1 error) {
	fake.SetRoleRulesStub = nil
	fake.setRoleRulesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeControl) SetRoleRulesReturnsOnCall(i int, result1 error) {
	fake.SetRoleRulesStub = nil
	if fake.setRoleRulesReturnsOnCall == nil {
		fake.setRoleRulesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setRoleRulesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeControl) GetAccountRoles(ctx context.Context, accountID rbac.AccountID) (rbac.AccountRoles, error) {
	fake.getAccountRolesMutex.Lock()
	ret, specificReturn := fake.getAccountRolesReturnsOnCall[len(fake.getAccountRolesArgsForCall)]
	fake.getAccountRolesArgsForCall = append(fake.getAccountRolesArgsForCall, struct {
		ctx       context.Context
		accountID rbac.AccountID
	}{ctx, accountID})
	fake.recordInvocation("GetAccountRoles", []interface{}{ctx, accountID})
	fake.getAccountRolesMutex.Unlock()
	if fake.GetAccountRolesStub != nil {
		return fake.GetAccountRolesStub(ctx, accountID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getAccountRolesReturns.result1, fake.getAccountRolesReturns.result2
}

func (fake *FakeControl) GetAccountRolesCallCount() int {
	fake.getAccountRolesMutex.RLock()
	defer fake.getAccountRolesMutex.RUnlock()
	return len(fake.getAccountRolesArgsForCall)
}

func (fake *FakeControl) GetAccountRolesArgsForCall(i int) (context.Context, rbac.AccountID) {
	fake.getAccountRolesMutex.RLock()
	defer fake.getAccountRolesMutex.RUnlock()
	return fake.getAccountRolesArgsForCall[i].ctx, fake.getAccountRolesArgsForCall[i].accountID
}

func (fake *FakeControl) GetAccountRolesReturns(result1 rbac.AccountRoles, result2 error) {
	fake.GetAccountRolesStub = nil
	fake.getAccountRolesReturns = struct {
		result1 rbac.AccountRoles
		result2 error
	}{result1, result2}
}

func (fake *FakeControl) GetAccountRolesReturnsOnCall(i int, result1 rbac.AccountRoles, result2 error) {
	fake.GetAccountRolesStub = nil
	if fake.getAccountRolesReturnsOnCall == nil {
		fake.getAccountRolesReturnsOnCall = make(map[int]struct {
			result1 rbac.AccountRoles
			result2 error
		})
	}
	fake.getAccountRolesReturnsOnCall[i] = struct {
		result1 rbac.AccountRoles
		result2 error
	}{result1, result2}
}

func (fake *FakeControl) SetAccountRoles(ctx context.Context, accountID rbac.AccountID, roles rbac.AccountRoles) error {
	fake.setAccountRolesMutex.Lock()
	ret, specificReturn := fake.setAccountRolesReturnsOnCall[len(fake.setAccountRolesArgsForCall)]
	fake.setAccountRolesArgsForCall = append(fake.setAccountRolesArgsForCall, struct {
		ctx       context.Context
		accountID rbac.AccountID
		roles     rbac.AccountRoles
	}{ctx, accountID, roles})
	fake.recordInvocation("SetAccountRoles", []interface{}{ctx, accountID, roles})
	fake.setAccountRolesMutex.Unlock()
	if fake.SetAccountRolesStub != nil {
		return fake.SetAccountRolesStub(ctx, accountID, roles)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setAccountRolesReturns.result1
}

func (fake *FakeControl) SetAccountRolesCallCount() int {
	fake.setAccountRolesMutex.RLock()
	defer fake.setAccountRolesMutex.RUnlock()
	return len(fake.setAccountRolesArgsForCall)
}

func (fake *FakeControl) SetAccountRolesArgsForCall(i int) (context.Context, rbac.AccountID, rbac.AccountRoles) {
	fake.setAccountRolesMutex.RLock()
	defer fake.setAccountRolesMutex.RUnlock()
	return fake.setAccountRolesArgsForCall[i].ctx, fake.setAccountRolesArgsForCall[i].accountID, fake.setAccountRolesArgsForCall[i].roles
}

func (fake *FakeControl) SetAccountRolesReturns(result1 error) {
	fake.SetAccountRolesStub = nil
	fake.setAccountRolesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeControl) SetAccountRolesReturnsOnCall(i int, result1 error) {
	fake.SetAccountRolesStub = nil
	if fake.setAccountRolesReturnsOnCall == nil {
		fake.setAccountRolesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setAccountRolesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeControl) IsAccountAllowed(ctx context.Context, accountID rbac.AccountID, rule rbac.Rule) (bool, error) {
	fake.isAccountAllowedMutex.Lock()
	ret, specificReturn := fake.isAccountAllowedReturnsOnCall[len(fake.isAccountAllowedArgsForCall)]
	fake.isAccountAllowedArgsForCall = append(fake.isAccountAllowedArgsForCall, struct {
		ctx       context.Context
		accountID rbac.AccountID
		rule      rbac.Rule
	}{ctx, accountID, rule})
	fake.recordInvocation("IsAccountAllowed", []interface{}{ctx, accountID, rule})
	fake.isAccountAllowedMutex.Unlock()
	if fake.IsAccountAllowedStub != nil {
		return fake.IsAccountAllowedStub(ctx, accountID, rule)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.isAccountAllowedReturns.result1, fake.isAccountAllowedReturns.result2
}

func (fake *FakeControl) IsAccountAllowedCallCount() int {
	fake.isAccountAllowedMutex.RLock()
	defer fake.isAccountAllowedMutex.RUnlock()
	return len(fake.isAccountAllowedArgsForCall)
}

func (fake *FakeControl) IsAccountAllowedArgsForCall(i int) (context.Context, rbac.AccountID, rbac.Rule) {
	fake.isAccountAllowedMutex.RLock()
	defer fake.isAccountAllowedMutex.RUnlock()
	return fake.isAccountAllowedArgsForCall[i].ctx, fake.isAccountAllowedArgsForCall[i].accountID, fake.isAccountAllowedArgsForCall[i].rule
}

func (fake *FakeControl) IsAccountAllowedReturns(result1 bool, result2 error) {
	fake.IsAccountAllowedStub = nil
	fake.isAccountAllowedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeControl) IsAccountAllowedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.IsAccountAllowedStub = nil
	if fake.isAccountAllowedReturnsOnCall == nil {
		fake.isAccountAllowedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isAccountAllowedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeControl) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getRoleRulesMutex.RLock()
	defer fake.getRoleRulesMutex.RUnlock()
	fake.setRoleRulesMutex.RLock()
	defer fake.setRoleRulesMutex.RUnlock()
	fake.getAccountRolesMutex.RLock()
	defer fake.getAccountRolesMutex.RUnlock()
	fake.setAccountRolesMutex.RLock()
	defer fake.setAccountRolesMutex.RUnlock()
	fake.isAccountAllowedMutex.RLock()
	defer fake.isAccountAllowedMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeControl) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ rbac.Control = new(FakeControl)
